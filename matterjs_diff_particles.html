<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.min.js"></script> -->
    <script src="matter.js"></script>
    <title>Document</title>
  </head>
  <body>
    <svg width="800" height="800" viewBox="0 0 1000 1000">
      <rect x="0" y="0" width="1000" height="1000" fill="#191919" />
      <g id="holder"></g>
    </svg>
  </body>
  <script>
    class Particle {
      constructor(x, y, r, matterball, type = "circle", isStatic = false) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.graphicHolder = null;
        this.graphic = null;
        this.matterball = matterball;
        this.type = type;
        this.namespace = "http://www.w3.org/2000/svg";
        this.isStatic = isStatic;
      }

      init(container, color = "#FF0000") {
        this.graphicHolder = this.getGraphicHolder();
        this.graphic =
          this.type == "circle" ? this.makeACircle() : this.makeARect();
        this.graphic.setAttribute("fill", color);
        this.graphic.setAttribute("fill-opacity", 0.2);
        this.graphic.setAttribute("stroke", color);
        this.graphic.setAttribute("stroke-width", "3");
        this.graphic.setAttribute("stroke-opacity", 1);
        this.graphicHolder.appendChild(this.graphic);
        container.appendChild(this.graphicHolder);
      }

      makeACircle() {
        const shape = document.createElementNS(this.namespace, "circle");
        shape.setAttribute("cx", 0);
        shape.setAttribute("cy", 0);
        shape.setAttribute("r", this.r);

        return shape;
      }

      makeARect() {
        const shape = document.createElementNS(this.namespace, "rect");
        shape.setAttribute("x", -this.r);
        shape.setAttribute("y", -this.r);
        shape.setAttribute("width", this.r * 2);
        shape.setAttribute("height", this.r * 2);

        return shape;
      }

      getGraphicHolder() {
        const namespace = "http://www.w3.org/2000/svg";
        const h = document.createElementNS(namespace, "g");
        return h;
      }

      update() {
        if (this.static) return;

        const pos = this.matterball.position;
        const angle = (180 / Math.PI) * this.matterball.angle;
        this.graphicHolder.setAttribute(
          "transform",
          `translate(${pos.x} ${pos.y}) rotate(${angle})`
        );
      }
    }

    class Windmill {
      constructor(x, y, w, matterbody = null) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.bladeHeight = 20;
        this.graphicHolder = null;
        this.matterbody = matterbody;
        this.namespace = "http://www.w3.org/2000/svg";
      }

      init(container) {
        this.graphicHolder = document.createElementNS(this.namespace, "g");
        container.appendChild(this.graphicHolder);
        this.graphicHolder.setAttribute(
          "transform",
          `translate(${this.x} ${this.y})`
        );

        this.makeBlades(this.graphicHolder);
        container.appendChild(this.graphicHolder);
      }

      makeBlades(holder) {
        const horizontalBlade = document.createElementNS(
          this.namespace,
          "rect"
        );
        horizontalBlade.setAttribute("x", -this.w / 2);
        horizontalBlade.setAttribute("y", -this.bladeHeight / 2);
        horizontalBlade.setAttribute("width", this.w);
        horizontalBlade.setAttribute("height", this.bladeHeight);
        horizontalBlade.setAttribute("fill", "#FFFFFF");

        const verticalBlade = document.createElementNS(this.namespace, "rect");
        verticalBlade.setAttribute("x", -this.bladeHeight / 2);
        verticalBlade.setAttribute("y", -this.w / 2);
        verticalBlade.setAttribute("width", this.bladeHeight);
        verticalBlade.setAttribute("height", this.w);
        verticalBlade.setAttribute("fill", "white");

        holder.appendChild(horizontalBlade);
        holder.appendChild(verticalBlade);
      }
      update() {
        const angle = (this.matterbody.bodies[0].angle * 180) / Math.PI;
        this.graphicHolder.setAttribute(
          "transform",
          `translate(${this.x} ${this.y}) rotate(${angle})`
        );
        // Matter.Composite.rotate(this.matterbody, 0.01, { x: 500, y: 500 });
      }
    }
    const { Engine, Render, Runner, Bodies, Composite, World } = Matter;
    let w = 1000;
    let h = 1000;

    const engine = Engine.create();
    const holder = document.querySelector("#holder");
    const balls = [];
    const pegs = [];
    const windmills = [];
    const windmillGraphics = [];
    const ballGraphics = [];
    const num = 100;
    const maxRadius = 5;

    const makeParticles = () => {
      for (let i = 0; i < num; i++) {
        const radius = 5 + Math.round(Math.random() * maxRadius);
        const xpos = 500 + (Math.random() * 100 - 50);
        const ypos = i * -radius;
        const type = Math.random() > 0.5 ? "circle" : "rect";

        const b =
          type == "circle"
            ? getCircBody(xpos, ypos, radius, i)
            : getRectBody(xpos, ypos, radius, i);
        const p = new Particle(xpos, ypos, radius, b, type);
        p.init(holder);
        balls.push(b);
        ballGraphics.push(p);
      }
    };

    const getCircBody = (xpos, ypos, radius, index, static = false) => {
      const b = Bodies.circle(xpos, ypos, radius, {
        id: `ball_${index}`,
        friction: 0,
        restitution: 1,
        isStatic: static,
      });

      return b;
    };

    const getRectBody = (xpos, ypos, radius, index, static = false) => {
      const b = Bodies.rectangle(xpos, ypos, radius * 2, radius * 2, {
        id: `ball_${index}`,
        friction: 0,
        restitution: 1,
        isStatic: static,
      });

      return b;
    };

    const leftwall = Bodies.rectangle(-50, 500, 100, 1000, {
      isStatic: true,
      id: "leftwall",
    });

    const rightwall = Bodies.rectangle(1050, 500, 100, 1000, {
      isStatic: true,
      id: "righttwall",
    });

    const makeWindmills = (xpos, ypos, width) => {
      const h = Bodies.rectangle(0, 0, 300, 20, {
        id: `horiz_blade`,
        friction: 0,
        restitution: 1,
        isStatic: true,
      });

      const v = Bodies.rectangle(0, 0, 20, 300, {
        id: `vert_blade`,
        friction: 0,
        restitution: 1,
        isStatic: true,
      });

      const comp = Matter.Composite.create();
      Matter.Composite.add(comp, [h, v]);
      Matter.Composite.translate(comp, { x: 500, y: 500 });
      windmills.push(comp);
      const wm = new Windmill(500, 500, 300, comp); //new Windmill(500, 500, 300,);
      wm.init(holder);
      windmillGraphics.push(wm);
    };
    const update = () => {
      ballGraphics.forEach((particle) => {
        particle.update();
      });

      balls.forEach((ball) => {
        if (ball.position.y > 1100) {
          Matter.Body.setPosition(ball, { x: 500, y: 0 });
          Matter.Body.setSpeed(ball, 0);
        }
      });

      windmills.forEach((windmill) => {
        //windmill.rotate(windmill.angle + 0.1);
        console.log("angle:", windmill.bodies[0].angle);
        const angle = windmill.bodies[0].angle;
        Matter.Composite.rotate(windmill, 0.01, { x: 500, y: 500 });
      });

      windmillGraphics.forEach((windmill) => {
        windmill.update();
      });
      window.requestAnimationFrame(update);
    };

    const initWorld = () => {
      let runner = Runner.create();
      World.add(engine.world, [...balls, ...windmills, leftwall, rightwall]);
      Runner.run(runner, engine);
    };

    makeParticles();
    makeWindmills();

    initWorld();

    update();
  </script>
</html>
