<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.min.js"></script> -->
    <script src="matter.js"></script>
    <title>Document</title>
  </head>
  <body>
    <svg width="800" height="800" viewBox="0 0 1000 1000">
      <rect x="0" y="0" width="1000" height="1000" fill="#191919" />
      <g id="holder"></g>
    </svg>
  </body>
  <script>
    class Particle {
      constructor(x, y, r, matterball, type = "circle", isStatic = false) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.graphicHolder = null;
        this.graphic = null;
        this.matterball = matterball;
        this.type = type;
        this.namespace = "http://www.w3.org/2000/svg";
        this.isStatic = isStatic;
      }

      init(container, color = "#FF0000") {
        this.graphicHolder = this.getGraphicHolder();
        this.graphic =
          this.type == "circle" ? this.makeACircle() : this.makeARect();
        this.graphic.setAttribute("fill", color);
        this.graphic.setAttribute("fill-opacity", 0.2);
        this.graphic.setAttribute("stroke", color);
        this.graphic.setAttribute("stroke-width", "3");
        this.graphic.setAttribute("stroke-opacity", 1);
        this.graphicHolder.appendChild(this.graphic);
        container.appendChild(this.graphicHolder);
      }

      makeACircle() {
        const shape = document.createElementNS(this.namespace, "circle");
        shape.setAttribute("cx", 0);
        shape.setAttribute("cy", 0);
        shape.setAttribute("r", this.r);

        return shape;
      }

      makeARect() {
        const shape = document.createElementNS(this.namespace, "rect");
        shape.setAttribute("x", -this.r);
        shape.setAttribute("y", -this.r);
        shape.setAttribute("width", this.r * 2);
        shape.setAttribute("height", this.r * 2);

        return shape;
      }

      getGraphicHolder() {
        const namespace = "http://www.w3.org/2000/svg";
        const h = document.createElementNS(namespace, "g");
        return h;
      }

      update() {
        if (this.static) return;

        const pos = this.matterball.position;
        const angle = (180 / Math.PI) * this.matterball.angle;
        this.graphicHolder.setAttribute(
          "transform",
          `translate(${pos.x} ${pos.y}) rotate(${angle})`
        );
      }
    }

    const { Engine, Render, Runner, Bodies, Composite, World } = Matter;
    let w = 1000;
    let h = 1000;

    const engine = Engine.create();
    const holder = document.querySelector("#holder");
    const balls = [];
    const pegs = [];
    const ballGraphics = [];
    const num = 100;
    const maxRadius = 5;

    const makeParticles = () => {
      for (let i = 0; i < num; i++) {
        const radius = 5 + Math.round(Math.random() * maxRadius);
        const xpos = 500 + (Math.random() * 100 - 50);
        const ypos = i * -radius;
        const type = Math.random() > 0.5 ? "circle" : "rect";

        const b =
          type == "circle"
            ? getCircBody(xpos, ypos, radius, i)
            : getRectBody(xpos, ypos, radius, i);
        const p = new Particle(xpos, ypos, radius, b, type);
        p.init(holder);
        balls.push(b);
        ballGraphics.push(p);
      }
    };

    const getCircBody = (xpos, ypos, radius, index, static = false) => {
      const b = Bodies.circle(xpos, ypos, radius, {
        id: `ball_${index}`,
        friction: 0,
        restitution: 1,
        isStatic: static,
      });

      return b;
    };

    const getRectBody = (xpos, ypos, radius, index, static = false) => {
      const b = Bodies.rectangle(xpos, ypos, radius * 2, radius * 2, {
        id: `ball_${index}`,
        friction: 0,
        restitution: 1,
        isStatic: static,
      });

      return b;
    };

    const makePegs = () => {
      const rows = 4;
      const cols = 8;
      const gap = 50;
      const radius = 30;
      const startX =
        radius + (w - (cols * (radius * 2) + (cols - 1) * gap)) / 2;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const xpos = startX + c * (radius * 2 + gap);
          const ypos = 200 + r * 200;
          const type = "circle";

          const b =
            type == "circle"
              ? getCircBody(xpos, ypos, radius, `${r}${c}`, true)
              : getRectBody(xpos, ypos, radius, `${r}${c}`, true);
          const p = new Particle(xpos, ypos, radius, b, type, true);
          p.init(holder, "#FFFFFF");
          pegs.push(b);
          ballGraphics.push(p);
        }
      }
    };

    // const floor = Bodies.rectangle(500, 1050, 1000, 100, {
    //   isStatic: true,
    //   id: "floor",
    // });

    const leftwall = Bodies.rectangle(-50, 500, 100, 1000, {
      isStatic: true,
      id: "leftwall",
    });

    const rightwall = Bodies.rectangle(1050, 500, 100, 1000, {
      isStatic: true,
      id: "righttwall",
    });

    // const peg = Bodies.circle(500, 500, 100, {
    //   isStatic: true,
    //   id: "peg",
    // });

    const update = () => {
      ballGraphics.forEach((particle) => {
        particle.update();
      });

      balls.forEach((ball) => {
        if (ball.position.y > 1100) {
          Matter.Body.setPosition(ball, { x: 500, y: 0 });
          // Matter.Body.setVelocity(ball, { x: 0, y: 0 });
          Matter.Body.setSpeed(ball, 0);
        }
      });
      window.requestAnimationFrame(update);
    };

    const initWorld = () => {
      let runner = Runner.create();
      World.add(engine.world, [...balls, ...pegs, leftwall, rightwall]);
      Runner.run(runner, engine);
    };

    makeParticles();
    makePegs();
    initWorld();

    update();
  </script>
</html>
