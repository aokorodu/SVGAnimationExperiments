<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.min.js"></script> -->
    <script src="JS/matter.js"></script>
    <script src="JS/Particle.js"></script>
    <script src="JS/Windmill.js"></script>
    <title>Document</title>
  </head>
  <body>
    <svg width="800" height="800" viewBox="0 0 1000 1000">
      <rect x="0" y="0" width="1000" height="1000" fill="#191919" />
      <g id="holder"></g>
    </svg>
  </body>
  <script>
    const { Engine, Render, Runner, Bodies, Composite, World } = Matter;
    let w = 1000;
    let h = 1000;

    const engine = Engine.create();
    const holder = document.querySelector("#holder");
    const balls = [];
    const pegs = [];
    const windmills = [];
    const windmillGraphics = [];
    const ballGraphics = [];
    const num = 100;
    const maxRadius = 3;
    const wmbladeWidth = 600;

    const makeParticles = () => {
      for (let i = 0; i < num; i++) {
        const radius = 5 + Math.round(Math.random() * maxRadius);
        const xpos = 500 + (Math.random() * 100 - 50);
        const ypos = i * -radius;
        const type = Math.random() > 0.5 ? "circle" : "rect";

        const b =
          type == "circle"
            ? getCircBody(xpos, ypos, radius, i)
            : getRectBody(xpos, ypos, radius, i);
        const p = new Particle(xpos, ypos, radius, b, type);
        p.init(holder);
        balls.push(b);
        ballGraphics.push(p);
      }
    };

    const getCircBody = (xpos, ypos, radius, index, static = false) => {
      const b = Bodies.circle(xpos, ypos, radius, {
        id: `ball_${index}`,
        friction: 0,
        restitution: 0.6,
        isStatic: static,
      });

      return b;
    };

    const getRectBody = (xpos, ypos, radius, index, static = false) => {
      const b = Bodies.rectangle(xpos, ypos, radius * 2, radius * 2, {
        id: `ball_${index}`,
        friction: 0,
        restitution: 0.6,
        isStatic: static,
      });

      return b;
    };

    const leftwall = Bodies.rectangle(-50, 500, 100, 1000, {
      isStatic: true,
      id: "leftwall",
    });

    const rightwall = Bodies.rectangle(1050, 500, 100, 1000, {
      isStatic: true,
      id: "righttwall",
    });

    const makeWindmills = (xpos, ypos, width) => {
      const h = Bodies.rectangle(0, 0, wmbladeWidth, 20, {
        id: `horiz_blade`,
        friction: 0,
        restitution: 1,
        isStatic: true,
      });

      const v = Bodies.rectangle(0, 0, 20, wmbladeWidth, {
        id: `vert_blade`,
        friction: 0,
        restitution: 1,
        isStatic: true,
      });

      const comp = Matter.Composite.create();
      Matter.Composite.add(comp, [h, v]);
      Matter.Composite.translate(comp, { x: 500, y: 500 });
      windmills.push(comp);
      const wm = new Windmill(500, 500, wmbladeWidth, comp); //new Windmill(500, 500, wmbladeWidth,);
      wm.init(holder);
      windmillGraphics.push(wm);
    };
    const update = () => {
      balls.forEach((ball) => {
        if (ball.position.y > 1100) {
          Matter.Body.setPosition(ball, { x: 400 + Math.random() * 200, y: 0 });
          Matter.Body.setSpeed(ball, 0);
        }
      });

      ballGraphics.forEach((particle) => {
        particle.update();
      });

      windmills.forEach((windmill) => {
        const angle = windmill.bodies[0].angle;
        Matter.Composite.rotate(windmill, 0.005, { x: 500, y: 500 });
      });

      windmillGraphics.forEach((windmill) => {
        windmill.update();
      });
      window.requestAnimationFrame(update);
    };

    const initWorld = () => {
      let runner = Runner.create();
      World.add(engine.world, [...balls, ...windmills, leftwall, rightwall]);
      Runner.run(runner, engine);
    };

    makeParticles();
    makeWindmills();

    initWorld();

    update();
  </script>
</html>
